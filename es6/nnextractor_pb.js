// source: nnextractor.proto
/**
 * @fileoverview
 * @enhanceable
 * @suppress {missingRequire} reports error on implicit type usages.
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!
/* eslint-disable */
// @ts-nocheck

goog.exportSymbol('proto.nnextractor.Item', null, global);
goog.exportSymbol('proto.nnextractor.ItemType', null, global);
goog.exportSymbol('proto.nnextractor.Items', null, global);
goog.exportSymbol('proto.nnextractor.NII', null, global);
goog.exportSymbol('proto.nnextractor.NNExtractor', null, global);
goog.exportSymbol('proto.nnextractor.NNNode', null, global);
goog.exportSymbol('proto.nnextractor.NNParameter', null, global);
goog.exportSymbol('proto.nnextractor.NNRecord', null, global);
goog.exportSymbol('proto.nnextractor.NNRecordMeta', null, global);
goog.exportSymbol('proto.nnextractor.NNRecordType', null, global);
goog.exportSymbol('proto.nnextractor.NNTensor', null, global);
goog.exportSymbol('proto.nnextractor.NNTensorType', null, global);
goog.exportSymbol('proto.nnextractor.OpItem', null, global);
goog.exportSymbol('proto.nnextractor.OpType', null, global);
goog.exportSymbol('proto.nnextractor.Primitive', null, global);
goog.exportSymbol('proto.nnextractor.PrimitiveType', null, global);
goog.exportSymbol('proto.nnextractor.RecursivePrimitive', null, global);
goog.exportSymbol('proto.nnextractor.RecursivePrimitiveType', null, global);
goog.exportSymbol('proto.nnextractor.Taskflow', null, global);
goog.exportSymbol('proto.nnextractor.TaskflowType', null, global);
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nnextractor.NNTensor = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.nnextractor.NNTensor.repeatedFields_, null);
};
goog.inherits(proto.nnextractor.NNTensor, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nnextractor.NNTensor.displayName = 'proto.nnextractor.NNTensor';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nnextractor.Primitive = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.nnextractor.Primitive, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nnextractor.Primitive.displayName = 'proto.nnextractor.Primitive';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nnextractor.RecursivePrimitive = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.nnextractor.RecursivePrimitive.repeatedFields_, null);
};
goog.inherits(proto.nnextractor.RecursivePrimitive, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nnextractor.RecursivePrimitive.displayName = 'proto.nnextractor.RecursivePrimitive';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nnextractor.NII = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.nnextractor.NII.repeatedFields_, null);
};
goog.inherits(proto.nnextractor.NII, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nnextractor.NII.displayName = 'proto.nnextractor.NII';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nnextractor.OpItem = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.nnextractor.OpItem, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nnextractor.OpItem.displayName = 'proto.nnextractor.OpItem';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nnextractor.Item = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.nnextractor.Item.repeatedFields_, null);
};
goog.inherits(proto.nnextractor.Item, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nnextractor.Item.displayName = 'proto.nnextractor.Item';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nnextractor.Items = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.nnextractor.Items.repeatedFields_, null);
};
goog.inherits(proto.nnextractor.Items, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nnextractor.Items.displayName = 'proto.nnextractor.Items';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nnextractor.NNRecordMeta = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.nnextractor.NNRecordMeta.repeatedFields_, null);
};
goog.inherits(proto.nnextractor.NNRecordMeta, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nnextractor.NNRecordMeta.displayName = 'proto.nnextractor.NNRecordMeta';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nnextractor.NNRecord = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.nnextractor.NNRecord.repeatedFields_, null);
};
goog.inherits(proto.nnextractor.NNRecord, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nnextractor.NNRecord.displayName = 'proto.nnextractor.NNRecord';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nnextractor.NNParameter = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.nnextractor.NNParameter, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nnextractor.NNParameter.displayName = 'proto.nnextractor.NNParameter';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nnextractor.NNNode = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.nnextractor.NNNode.repeatedFields_, null);
};
goog.inherits(proto.nnextractor.NNNode, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nnextractor.NNNode.displayName = 'proto.nnextractor.NNNode';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nnextractor.Taskflow = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.nnextractor.Taskflow, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nnextractor.Taskflow.displayName = 'proto.nnextractor.Taskflow';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.nnextractor.NNExtractor = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.nnextractor.NNExtractor.repeatedFields_, null);
};
goog.inherits(proto.nnextractor.NNExtractor, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.nnextractor.NNExtractor.displayName = 'proto.nnextractor.NNExtractor';
}

/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.nnextractor.NNTensor.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nnextractor.NNTensor.prototype.toObject = function(opt_includeInstance) {
  return proto.nnextractor.NNTensor.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nnextractor.NNTensor} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nnextractor.NNTensor.toObject = function(includeInstance, msg) {
  var f, obj = {
shapeList: (f = jspb.Message.getRepeatedField(msg, 1)) == null ? undefined : f,
theBytes: msg.getTheBytes_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nnextractor.NNTensor}
 */
proto.nnextractor.NNTensor.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nnextractor.NNTensor;
  return proto.nnextractor.NNTensor.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nnextractor.NNTensor} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nnextractor.NNTensor}
 */
proto.nnextractor.NNTensor.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var values = /** @type {!Array<number>} */ (reader.isDelimited() ? reader.readPackedSint32() : [reader.readSint32()]);
      for (var i = 0; i < values.length; i++) {
        msg.addShape(values[i]);
      }
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTheBytes(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nnextractor.NNTensor.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nnextractor.NNTensor.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nnextractor.NNTensor} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nnextractor.NNTensor.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getShapeList();
  if (f.length > 0) {
    writer.writePackedSint32(
      1,
      f
    );
  }
  f = message.getTheBytes_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * repeated sint32 shape = 1;
 * @return {!Array<number>}
 */
proto.nnextractor.NNTensor.prototype.getShapeList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 1));
};


/**
 * @param {!Array<number>} value
 * @return {!proto.nnextractor.NNTensor} returns this
 */
proto.nnextractor.NNTensor.prototype.setShapeList = function(value) {
  return jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {number} value
 * @param {number=} opt_index
 * @return {!proto.nnextractor.NNTensor} returns this
 */
proto.nnextractor.NNTensor.prototype.addShape = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nnextractor.NNTensor} returns this
 */
proto.nnextractor.NNTensor.prototype.clearShapeList = function() {
  return this.setShapeList([]);
};


/**
 * optional bytes the_bytes = 2;
 * @return {!(string|Uint8Array)}
 */
proto.nnextractor.NNTensor.prototype.getTheBytes = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes the_bytes = 2;
 * This is a type-conversion wrapper around `getTheBytes()`
 * @return {string}
 */
proto.nnextractor.NNTensor.prototype.getTheBytes_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTheBytes()));
};


/**
 * optional bytes the_bytes = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTheBytes()`
 * @return {!Uint8Array}
 */
proto.nnextractor.NNTensor.prototype.getTheBytes_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTheBytes()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.nnextractor.NNTensor} returns this
 */
proto.nnextractor.NNTensor.prototype.setTheBytes = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nnextractor.Primitive.prototype.toObject = function(opt_includeInstance) {
  return proto.nnextractor.Primitive.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nnextractor.Primitive} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nnextractor.Primitive.toObject = function(includeInstance, msg) {
  var f, obj = {
theType: jspb.Message.getFieldWithDefault(msg, 1, 0),
b: (f = jspb.Message.getBooleanField(msg, 2)) == null ? undefined : f,
s: (f = jspb.Message.getField(msg, 3)) == null ? undefined : f,
f64: (f = jspb.Message.getOptionalFloatingPointField(msg, 4)) == null ? undefined : f,
f32: (f = jspb.Message.getOptionalFloatingPointField(msg, 5)) == null ? undefined : f,
i64: (f = jspb.Message.getField(msg, 6)) == null ? undefined : f,
i32: (f = jspb.Message.getField(msg, 7)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nnextractor.Primitive}
 */
proto.nnextractor.Primitive.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nnextractor.Primitive;
  return proto.nnextractor.Primitive.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nnextractor.Primitive} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nnextractor.Primitive}
 */
proto.nnextractor.Primitive.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.nnextractor.PrimitiveType} */ (reader.readEnum());
      msg.setTheType(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setB(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setS(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readDouble());
      msg.setF64(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setF32(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readSint64());
      msg.setI64(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readSint32());
      msg.setI32(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nnextractor.Primitive.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nnextractor.Primitive.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nnextractor.Primitive} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nnextractor.Primitive.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTheType();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBool(
      2,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeString(
      3,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeDouble(
      4,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeFloat(
      5,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeSint64(
      6,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeSint32(
      7,
      f
    );
  }
};


/**
 * optional PrimitiveType the_type = 1;
 * @return {!proto.nnextractor.PrimitiveType}
 */
proto.nnextractor.Primitive.prototype.getTheType = function() {
  return /** @type {!proto.nnextractor.PrimitiveType} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.nnextractor.PrimitiveType} value
 * @return {!proto.nnextractor.Primitive} returns this
 */
proto.nnextractor.Primitive.prototype.setTheType = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional bool b = 2;
 * @return {boolean}
 */
proto.nnextractor.Primitive.prototype.getB = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 2, false));
};


/**
 * @param {boolean} value
 * @return {!proto.nnextractor.Primitive} returns this
 */
proto.nnextractor.Primitive.prototype.setB = function(value) {
  return jspb.Message.setField(this, 2, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.nnextractor.Primitive} returns this
 */
proto.nnextractor.Primitive.prototype.clearB = function() {
  return jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nnextractor.Primitive.prototype.hasB = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional string s = 3;
 * @return {string}
 */
proto.nnextractor.Primitive.prototype.getS = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.nnextractor.Primitive} returns this
 */
proto.nnextractor.Primitive.prototype.setS = function(value) {
  return jspb.Message.setField(this, 3, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.nnextractor.Primitive} returns this
 */
proto.nnextractor.Primitive.prototype.clearS = function() {
  return jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nnextractor.Primitive.prototype.hasS = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional double f64 = 4;
 * @return {number}
 */
proto.nnextractor.Primitive.prototype.getF64 = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 4, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.nnextractor.Primitive} returns this
 */
proto.nnextractor.Primitive.prototype.setF64 = function(value) {
  return jspb.Message.setField(this, 4, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.nnextractor.Primitive} returns this
 */
proto.nnextractor.Primitive.prototype.clearF64 = function() {
  return jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nnextractor.Primitive.prototype.hasF64 = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional float f32 = 5;
 * @return {number}
 */
proto.nnextractor.Primitive.prototype.getF32 = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 5, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.nnextractor.Primitive} returns this
 */
proto.nnextractor.Primitive.prototype.setF32 = function(value) {
  return jspb.Message.setField(this, 5, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.nnextractor.Primitive} returns this
 */
proto.nnextractor.Primitive.prototype.clearF32 = function() {
  return jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nnextractor.Primitive.prototype.hasF32 = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional sint64 i64 = 6;
 * @return {number}
 */
proto.nnextractor.Primitive.prototype.getI64 = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/**
 * @param {number} value
 * @return {!proto.nnextractor.Primitive} returns this
 */
proto.nnextractor.Primitive.prototype.setI64 = function(value) {
  return jspb.Message.setField(this, 6, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.nnextractor.Primitive} returns this
 */
proto.nnextractor.Primitive.prototype.clearI64 = function() {
  return jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nnextractor.Primitive.prototype.hasI64 = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional sint32 i32 = 7;
 * @return {number}
 */
proto.nnextractor.Primitive.prototype.getI32 = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/**
 * @param {number} value
 * @return {!proto.nnextractor.Primitive} returns this
 */
proto.nnextractor.Primitive.prototype.setI32 = function(value) {
  return jspb.Message.setField(this, 7, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.nnextractor.Primitive} returns this
 */
proto.nnextractor.Primitive.prototype.clearI32 = function() {
  return jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nnextractor.Primitive.prototype.hasI32 = function() {
  return jspb.Message.getField(this, 7) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.nnextractor.RecursivePrimitive.repeatedFields_ = [3,5];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nnextractor.RecursivePrimitive.prototype.toObject = function(opt_includeInstance) {
  return proto.nnextractor.RecursivePrimitive.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nnextractor.RecursivePrimitive} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nnextractor.RecursivePrimitive.toObject = function(includeInstance, msg) {
  var f, obj = {
theType: jspb.Message.getFieldWithDefault(msg, 1, 0),
primitive: (f = msg.getPrimitive()) && proto.nnextractor.Primitive.toObject(includeInstance, f),
primitivesList: jspb.Message.toObjectList(msg.getPrimitivesList(),
    proto.nnextractor.RecursivePrimitive.toObject, includeInstance),
primitiveMapMap: (f = msg.getPrimitiveMapMap()) ? f.toObject(includeInstance, proto.nnextractor.RecursivePrimitive.toObject) : [],
sliceList: (f = jspb.Message.getRepeatedField(msg, 5)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nnextractor.RecursivePrimitive}
 */
proto.nnextractor.RecursivePrimitive.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nnextractor.RecursivePrimitive;
  return proto.nnextractor.RecursivePrimitive.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nnextractor.RecursivePrimitive} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nnextractor.RecursivePrimitive}
 */
proto.nnextractor.RecursivePrimitive.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.nnextractor.RecursivePrimitiveType} */ (reader.readEnum());
      msg.setTheType(value);
      break;
    case 2:
      var value = new proto.nnextractor.Primitive;
      reader.readMessage(value,proto.nnextractor.Primitive.deserializeBinaryFromReader);
      msg.setPrimitive(value);
      break;
    case 3:
      var value = new proto.nnextractor.RecursivePrimitive;
      reader.readMessage(value,proto.nnextractor.RecursivePrimitive.deserializeBinaryFromReader);
      msg.addPrimitives(value);
      break;
    case 4:
      var value = msg.getPrimitiveMapMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readMessage, proto.nnextractor.RecursivePrimitive.deserializeBinaryFromReader, "", new proto.nnextractor.RecursivePrimitive());
         });
      break;
    case 5:
      var values = /** @type {!Array<number>} */ (reader.isDelimited() ? reader.readPackedSint32() : [reader.readSint32()]);
      for (var i = 0; i < values.length; i++) {
        msg.addSlice(values[i]);
      }
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nnextractor.RecursivePrimitive.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nnextractor.RecursivePrimitive.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nnextractor.RecursivePrimitive} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nnextractor.RecursivePrimitive.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTheType();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getPrimitive();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.nnextractor.Primitive.serializeBinaryToWriter
    );
  }
  f = message.getPrimitivesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.nnextractor.RecursivePrimitive.serializeBinaryToWriter
    );
  }
  f = message.getPrimitiveMapMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(4, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeMessage, proto.nnextractor.RecursivePrimitive.serializeBinaryToWriter);
  }
  f = message.getSliceList();
  if (f.length > 0) {
    writer.writePackedSint32(
      5,
      f
    );
  }
};


/**
 * optional RecursivePrimitiveType the_type = 1;
 * @return {!proto.nnextractor.RecursivePrimitiveType}
 */
proto.nnextractor.RecursivePrimitive.prototype.getTheType = function() {
  return /** @type {!proto.nnextractor.RecursivePrimitiveType} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.nnextractor.RecursivePrimitiveType} value
 * @return {!proto.nnextractor.RecursivePrimitive} returns this
 */
proto.nnextractor.RecursivePrimitive.prototype.setTheType = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional Primitive primitive = 2;
 * @return {?proto.nnextractor.Primitive}
 */
proto.nnextractor.RecursivePrimitive.prototype.getPrimitive = function() {
  return /** @type{?proto.nnextractor.Primitive} */ (
    jspb.Message.getWrapperField(this, proto.nnextractor.Primitive, 2));
};


/**
 * @param {?proto.nnextractor.Primitive|undefined} value
 * @return {!proto.nnextractor.RecursivePrimitive} returns this
*/
proto.nnextractor.RecursivePrimitive.prototype.setPrimitive = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nnextractor.RecursivePrimitive} returns this
 */
proto.nnextractor.RecursivePrimitive.prototype.clearPrimitive = function() {
  return this.setPrimitive(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nnextractor.RecursivePrimitive.prototype.hasPrimitive = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * repeated RecursivePrimitive primitives = 3;
 * @return {!Array<!proto.nnextractor.RecursivePrimitive>}
 */
proto.nnextractor.RecursivePrimitive.prototype.getPrimitivesList = function() {
  return /** @type{!Array<!proto.nnextractor.RecursivePrimitive>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.nnextractor.RecursivePrimitive, 3));
};


/**
 * @param {!Array<!proto.nnextractor.RecursivePrimitive>} value
 * @return {!proto.nnextractor.RecursivePrimitive} returns this
*/
proto.nnextractor.RecursivePrimitive.prototype.setPrimitivesList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.nnextractor.RecursivePrimitive=} opt_value
 * @param {number=} opt_index
 * @return {!proto.nnextractor.RecursivePrimitive}
 */
proto.nnextractor.RecursivePrimitive.prototype.addPrimitives = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.nnextractor.RecursivePrimitive, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nnextractor.RecursivePrimitive} returns this
 */
proto.nnextractor.RecursivePrimitive.prototype.clearPrimitivesList = function() {
  return this.setPrimitivesList([]);
};


/**
 * map<string, RecursivePrimitive> primitive_map = 4;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,!proto.nnextractor.RecursivePrimitive>}
 */
proto.nnextractor.RecursivePrimitive.prototype.getPrimitiveMapMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,!proto.nnextractor.RecursivePrimitive>} */ (
      jspb.Message.getMapField(this, 4, opt_noLazyCreate,
      proto.nnextractor.RecursivePrimitive));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.nnextractor.RecursivePrimitive} returns this
 */
proto.nnextractor.RecursivePrimitive.prototype.clearPrimitiveMapMap = function() {
  this.getPrimitiveMapMap().clear();
  return this;
};


/**
 * repeated sint32 slice = 5;
 * @return {!Array<number>}
 */
proto.nnextractor.RecursivePrimitive.prototype.getSliceList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 5));
};


/**
 * @param {!Array<number>} value
 * @return {!proto.nnextractor.RecursivePrimitive} returns this
 */
proto.nnextractor.RecursivePrimitive.prototype.setSliceList = function(value) {
  return jspb.Message.setField(this, 5, value || []);
};


/**
 * @param {number} value
 * @param {number=} opt_index
 * @return {!proto.nnextractor.RecursivePrimitive} returns this
 */
proto.nnextractor.RecursivePrimitive.prototype.addSlice = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 5, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nnextractor.RecursivePrimitive} returns this
 */
proto.nnextractor.RecursivePrimitive.prototype.clearSliceList = function() {
  return this.setSliceList([]);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.nnextractor.NII.repeatedFields_ = [2,3,4,5];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nnextractor.NII.prototype.toObject = function(opt_includeInstance) {
  return proto.nnextractor.NII.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nnextractor.NII} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nnextractor.NII.toObject = function(includeInstance, msg) {
  var f, obj = {
tensor: (f = msg.getTensor()) && proto.nnextractor.NNTensor.toObject(includeInstance, f),
originList: (f = jspb.Message.getRepeatedFloatingPointField(msg, 2)) == null ? undefined : f,
directionList: (f = jspb.Message.getRepeatedFloatingPointField(msg, 3)) == null ? undefined : f,
spacingList: (f = jspb.Message.getRepeatedFloatingPointField(msg, 4)) == null ? undefined : f,
affineList: (f = jspb.Message.getRepeatedFloatingPointField(msg, 5)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nnextractor.NII}
 */
proto.nnextractor.NII.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nnextractor.NII;
  return proto.nnextractor.NII.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nnextractor.NII} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nnextractor.NII}
 */
proto.nnextractor.NII.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.nnextractor.NNTensor;
      reader.readMessage(value,proto.nnextractor.NNTensor.deserializeBinaryFromReader);
      msg.setTensor(value);
      break;
    case 2:
      var values = /** @type {!Array<number>} */ (reader.isDelimited() ? reader.readPackedDouble() : [reader.readDouble()]);
      for (var i = 0; i < values.length; i++) {
        msg.addOrigin(values[i]);
      }
      break;
    case 3:
      var values = /** @type {!Array<number>} */ (reader.isDelimited() ? reader.readPackedDouble() : [reader.readDouble()]);
      for (var i = 0; i < values.length; i++) {
        msg.addDirection(values[i]);
      }
      break;
    case 4:
      var values = /** @type {!Array<number>} */ (reader.isDelimited() ? reader.readPackedDouble() : [reader.readDouble()]);
      for (var i = 0; i < values.length; i++) {
        msg.addSpacing(values[i]);
      }
      break;
    case 5:
      var values = /** @type {!Array<number>} */ (reader.isDelimited() ? reader.readPackedDouble() : [reader.readDouble()]);
      for (var i = 0; i < values.length; i++) {
        msg.addAffine(values[i]);
      }
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nnextractor.NII.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nnextractor.NII.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nnextractor.NII} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nnextractor.NII.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTensor();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.nnextractor.NNTensor.serializeBinaryToWriter
    );
  }
  f = message.getOriginList();
  if (f.length > 0) {
    writer.writePackedDouble(
      2,
      f
    );
  }
  f = message.getDirectionList();
  if (f.length > 0) {
    writer.writePackedDouble(
      3,
      f
    );
  }
  f = message.getSpacingList();
  if (f.length > 0) {
    writer.writePackedDouble(
      4,
      f
    );
  }
  f = message.getAffineList();
  if (f.length > 0) {
    writer.writePackedDouble(
      5,
      f
    );
  }
};


/**
 * optional NNTensor tensor = 1;
 * @return {?proto.nnextractor.NNTensor}
 */
proto.nnextractor.NII.prototype.getTensor = function() {
  return /** @type{?proto.nnextractor.NNTensor} */ (
    jspb.Message.getWrapperField(this, proto.nnextractor.NNTensor, 1));
};


/**
 * @param {?proto.nnextractor.NNTensor|undefined} value
 * @return {!proto.nnextractor.NII} returns this
*/
proto.nnextractor.NII.prototype.setTensor = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nnextractor.NII} returns this
 */
proto.nnextractor.NII.prototype.clearTensor = function() {
  return this.setTensor(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nnextractor.NII.prototype.hasTensor = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * repeated double origin = 2;
 * @return {!Array<number>}
 */
proto.nnextractor.NII.prototype.getOriginList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedFloatingPointField(this, 2));
};


/**
 * @param {!Array<number>} value
 * @return {!proto.nnextractor.NII} returns this
 */
proto.nnextractor.NII.prototype.setOriginList = function(value) {
  return jspb.Message.setField(this, 2, value || []);
};


/**
 * @param {number} value
 * @param {number=} opt_index
 * @return {!proto.nnextractor.NII} returns this
 */
proto.nnextractor.NII.prototype.addOrigin = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 2, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nnextractor.NII} returns this
 */
proto.nnextractor.NII.prototype.clearOriginList = function() {
  return this.setOriginList([]);
};


/**
 * repeated double direction = 3;
 * @return {!Array<number>}
 */
proto.nnextractor.NII.prototype.getDirectionList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedFloatingPointField(this, 3));
};


/**
 * @param {!Array<number>} value
 * @return {!proto.nnextractor.NII} returns this
 */
proto.nnextractor.NII.prototype.setDirectionList = function(value) {
  return jspb.Message.setField(this, 3, value || []);
};


/**
 * @param {number} value
 * @param {number=} opt_index
 * @return {!proto.nnextractor.NII} returns this
 */
proto.nnextractor.NII.prototype.addDirection = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 3, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nnextractor.NII} returns this
 */
proto.nnextractor.NII.prototype.clearDirectionList = function() {
  return this.setDirectionList([]);
};


/**
 * repeated double spacing = 4;
 * @return {!Array<number>}
 */
proto.nnextractor.NII.prototype.getSpacingList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedFloatingPointField(this, 4));
};


/**
 * @param {!Array<number>} value
 * @return {!proto.nnextractor.NII} returns this
 */
proto.nnextractor.NII.prototype.setSpacingList = function(value) {
  return jspb.Message.setField(this, 4, value || []);
};


/**
 * @param {number} value
 * @param {number=} opt_index
 * @return {!proto.nnextractor.NII} returns this
 */
proto.nnextractor.NII.prototype.addSpacing = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 4, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nnextractor.NII} returns this
 */
proto.nnextractor.NII.prototype.clearSpacingList = function() {
  return this.setSpacingList([]);
};


/**
 * repeated double affine = 5;
 * @return {!Array<number>}
 */
proto.nnextractor.NII.prototype.getAffineList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedFloatingPointField(this, 5));
};


/**
 * @param {!Array<number>} value
 * @return {!proto.nnextractor.NII} returns this
 */
proto.nnextractor.NII.prototype.setAffineList = function(value) {
  return jspb.Message.setField(this, 5, value || []);
};


/**
 * @param {number} value
 * @param {number=} opt_index
 * @return {!proto.nnextractor.NII} returns this
 */
proto.nnextractor.NII.prototype.addAffine = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 5, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nnextractor.NII} returns this
 */
proto.nnextractor.NII.prototype.clearAffineList = function() {
  return this.setAffineList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nnextractor.OpItem.prototype.toObject = function(opt_includeInstance) {
  return proto.nnextractor.OpItem.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nnextractor.OpItem} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nnextractor.OpItem.toObject = function(includeInstance, msg) {
  var f, obj = {
name: jspb.Message.getFieldWithDefault(msg, 1, ""),
opType: jspb.Message.getFieldWithDefault(msg, 2, 0),
tensor: (f = msg.getTensor()) && proto.nnextractor.NNTensor.toObject(includeInstance, f),
opParams: (f = msg.getOpParams()) && proto.nnextractor.RecursivePrimitive.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nnextractor.OpItem}
 */
proto.nnextractor.OpItem.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nnextractor.OpItem;
  return proto.nnextractor.OpItem.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nnextractor.OpItem} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nnextractor.OpItem}
 */
proto.nnextractor.OpItem.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setName(value);
      break;
    case 2:
      var value = /** @type {!proto.nnextractor.OpType} */ (reader.readEnum());
      msg.setOpType(value);
      break;
    case 3:
      var value = new proto.nnextractor.NNTensor;
      reader.readMessage(value,proto.nnextractor.NNTensor.deserializeBinaryFromReader);
      msg.setTensor(value);
      break;
    case 4:
      var value = new proto.nnextractor.RecursivePrimitive;
      reader.readMessage(value,proto.nnextractor.RecursivePrimitive.deserializeBinaryFromReader);
      msg.setOpParams(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nnextractor.OpItem.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nnextractor.OpItem.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nnextractor.OpItem} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nnextractor.OpItem.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getName();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getOpType();
  if (f !== 0.0) {
    writer.writeEnum(
      2,
      f
    );
  }
  f = message.getTensor();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.nnextractor.NNTensor.serializeBinaryToWriter
    );
  }
  f = message.getOpParams();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.nnextractor.RecursivePrimitive.serializeBinaryToWriter
    );
  }
};


/**
 * optional string name = 1;
 * @return {string}
 */
proto.nnextractor.OpItem.prototype.getName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.nnextractor.OpItem} returns this
 */
proto.nnextractor.OpItem.prototype.setName = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional OpType op_type = 2;
 * @return {!proto.nnextractor.OpType}
 */
proto.nnextractor.OpItem.prototype.getOpType = function() {
  return /** @type {!proto.nnextractor.OpType} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {!proto.nnextractor.OpType} value
 * @return {!proto.nnextractor.OpItem} returns this
 */
proto.nnextractor.OpItem.prototype.setOpType = function(value) {
  return jspb.Message.setProto3EnumField(this, 2, value);
};


/**
 * optional NNTensor tensor = 3;
 * @return {?proto.nnextractor.NNTensor}
 */
proto.nnextractor.OpItem.prototype.getTensor = function() {
  return /** @type{?proto.nnextractor.NNTensor} */ (
    jspb.Message.getWrapperField(this, proto.nnextractor.NNTensor, 3));
};


/**
 * @param {?proto.nnextractor.NNTensor|undefined} value
 * @return {!proto.nnextractor.OpItem} returns this
*/
proto.nnextractor.OpItem.prototype.setTensor = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nnextractor.OpItem} returns this
 */
proto.nnextractor.OpItem.prototype.clearTensor = function() {
  return this.setTensor(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nnextractor.OpItem.prototype.hasTensor = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional RecursivePrimitive op_params = 4;
 * @return {?proto.nnextractor.RecursivePrimitive}
 */
proto.nnextractor.OpItem.prototype.getOpParams = function() {
  return /** @type{?proto.nnextractor.RecursivePrimitive} */ (
    jspb.Message.getWrapperField(this, proto.nnextractor.RecursivePrimitive, 4));
};


/**
 * @param {?proto.nnextractor.RecursivePrimitive|undefined} value
 * @return {!proto.nnextractor.OpItem} returns this
*/
proto.nnextractor.OpItem.prototype.setOpParams = function(value) {
  return jspb.Message.setWrapperField(this, 4, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nnextractor.OpItem} returns this
 */
proto.nnextractor.OpItem.prototype.clearOpParams = function() {
  return this.setOpParams(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nnextractor.OpItem.prototype.hasOpParams = function() {
  return jspb.Message.getField(this, 4) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.nnextractor.Item.repeatedFields_ = [7];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nnextractor.Item.prototype.toObject = function(opt_includeInstance) {
  return proto.nnextractor.Item.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nnextractor.Item} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nnextractor.Item.toObject = function(includeInstance, msg) {
  var f, obj = {
name: jspb.Message.getFieldWithDefault(msg, 1, ""),
theType: jspb.Message.getFieldWithDefault(msg, 2, 0),
otherType: (f = jspb.Message.getField(msg, 3)) == null ? undefined : f,
primitive: (f = msg.getPrimitive()) && proto.nnextractor.Primitive.toObject(includeInstance, f),
tensor: (f = msg.getTensor()) && proto.nnextractor.NNTensor.toObject(includeInstance, f),
nii: (f = msg.getNii()) && proto.nnextractor.NII.toObject(includeInstance, f),
theListList: jspb.Message.toObjectList(msg.getTheListList(),
    proto.nnextractor.Item.toObject, includeInstance),
theMapMap: (f = msg.getTheMapMap()) ? f.toObject(includeInstance, proto.nnextractor.Item.toObject) : [],
opItem: (f = msg.getOpItem()) && proto.nnextractor.OpItem.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nnextractor.Item}
 */
proto.nnextractor.Item.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nnextractor.Item;
  return proto.nnextractor.Item.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nnextractor.Item} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nnextractor.Item}
 */
proto.nnextractor.Item.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setName(value);
      break;
    case 2:
      var value = /** @type {!proto.nnextractor.ItemType} */ (reader.readEnum());
      msg.setTheType(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setOtherType(value);
      break;
    case 4:
      var value = new proto.nnextractor.Primitive;
      reader.readMessage(value,proto.nnextractor.Primitive.deserializeBinaryFromReader);
      msg.setPrimitive(value);
      break;
    case 5:
      var value = new proto.nnextractor.NNTensor;
      reader.readMessage(value,proto.nnextractor.NNTensor.deserializeBinaryFromReader);
      msg.setTensor(value);
      break;
    case 6:
      var value = new proto.nnextractor.NII;
      reader.readMessage(value,proto.nnextractor.NII.deserializeBinaryFromReader);
      msg.setNii(value);
      break;
    case 7:
      var value = new proto.nnextractor.Item;
      reader.readMessage(value,proto.nnextractor.Item.deserializeBinaryFromReader);
      msg.addTheList(value);
      break;
    case 8:
      var value = msg.getTheMapMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readMessage, proto.nnextractor.Item.deserializeBinaryFromReader, "", new proto.nnextractor.Item());
         });
      break;
    case 9:
      var value = new proto.nnextractor.OpItem;
      reader.readMessage(value,proto.nnextractor.OpItem.deserializeBinaryFromReader);
      msg.setOpItem(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nnextractor.Item.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nnextractor.Item.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nnextractor.Item} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nnextractor.Item.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getName();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getTheType();
  if (f !== 0.0) {
    writer.writeEnum(
      2,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getPrimitive();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.nnextractor.Primitive.serializeBinaryToWriter
    );
  }
  f = message.getTensor();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.nnextractor.NNTensor.serializeBinaryToWriter
    );
  }
  f = message.getNii();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.nnextractor.NII.serializeBinaryToWriter
    );
  }
  f = message.getTheListList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      7,
      f,
      proto.nnextractor.Item.serializeBinaryToWriter
    );
  }
  f = message.getTheMapMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(8, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeMessage, proto.nnextractor.Item.serializeBinaryToWriter);
  }
  f = message.getOpItem();
  if (f != null) {
    writer.writeMessage(
      9,
      f,
      proto.nnextractor.OpItem.serializeBinaryToWriter
    );
  }
};


/**
 * optional string name = 1;
 * @return {string}
 */
proto.nnextractor.Item.prototype.getName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.nnextractor.Item} returns this
 */
proto.nnextractor.Item.prototype.setName = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional ItemType the_type = 2;
 * @return {!proto.nnextractor.ItemType}
 */
proto.nnextractor.Item.prototype.getTheType = function() {
  return /** @type {!proto.nnextractor.ItemType} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {!proto.nnextractor.ItemType} value
 * @return {!proto.nnextractor.Item} returns this
 */
proto.nnextractor.Item.prototype.setTheType = function(value) {
  return jspb.Message.setProto3EnumField(this, 2, value);
};


/**
 * optional string other_type = 3;
 * @return {string}
 */
proto.nnextractor.Item.prototype.getOtherType = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.nnextractor.Item} returns this
 */
proto.nnextractor.Item.prototype.setOtherType = function(value) {
  return jspb.Message.setField(this, 3, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.nnextractor.Item} returns this
 */
proto.nnextractor.Item.prototype.clearOtherType = function() {
  return jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nnextractor.Item.prototype.hasOtherType = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional Primitive primitive = 4;
 * @return {?proto.nnextractor.Primitive}
 */
proto.nnextractor.Item.prototype.getPrimitive = function() {
  return /** @type{?proto.nnextractor.Primitive} */ (
    jspb.Message.getWrapperField(this, proto.nnextractor.Primitive, 4));
};


/**
 * @param {?proto.nnextractor.Primitive|undefined} value
 * @return {!proto.nnextractor.Item} returns this
*/
proto.nnextractor.Item.prototype.setPrimitive = function(value) {
  return jspb.Message.setWrapperField(this, 4, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nnextractor.Item} returns this
 */
proto.nnextractor.Item.prototype.clearPrimitive = function() {
  return this.setPrimitive(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nnextractor.Item.prototype.hasPrimitive = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional NNTensor tensor = 5;
 * @return {?proto.nnextractor.NNTensor}
 */
proto.nnextractor.Item.prototype.getTensor = function() {
  return /** @type{?proto.nnextractor.NNTensor} */ (
    jspb.Message.getWrapperField(this, proto.nnextractor.NNTensor, 5));
};


/**
 * @param {?proto.nnextractor.NNTensor|undefined} value
 * @return {!proto.nnextractor.Item} returns this
*/
proto.nnextractor.Item.prototype.setTensor = function(value) {
  return jspb.Message.setWrapperField(this, 5, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nnextractor.Item} returns this
 */
proto.nnextractor.Item.prototype.clearTensor = function() {
  return this.setTensor(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nnextractor.Item.prototype.hasTensor = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional NII nii = 6;
 * @return {?proto.nnextractor.NII}
 */
proto.nnextractor.Item.prototype.getNii = function() {
  return /** @type{?proto.nnextractor.NII} */ (
    jspb.Message.getWrapperField(this, proto.nnextractor.NII, 6));
};


/**
 * @param {?proto.nnextractor.NII|undefined} value
 * @return {!proto.nnextractor.Item} returns this
*/
proto.nnextractor.Item.prototype.setNii = function(value) {
  return jspb.Message.setWrapperField(this, 6, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nnextractor.Item} returns this
 */
proto.nnextractor.Item.prototype.clearNii = function() {
  return this.setNii(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nnextractor.Item.prototype.hasNii = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * repeated Item the_list = 7;
 * @return {!Array<!proto.nnextractor.Item>}
 */
proto.nnextractor.Item.prototype.getTheListList = function() {
  return /** @type{!Array<!proto.nnextractor.Item>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.nnextractor.Item, 7));
};


/**
 * @param {!Array<!proto.nnextractor.Item>} value
 * @return {!proto.nnextractor.Item} returns this
*/
proto.nnextractor.Item.prototype.setTheListList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 7, value);
};


/**
 * @param {!proto.nnextractor.Item=} opt_value
 * @param {number=} opt_index
 * @return {!proto.nnextractor.Item}
 */
proto.nnextractor.Item.prototype.addTheList = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 7, opt_value, proto.nnextractor.Item, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nnextractor.Item} returns this
 */
proto.nnextractor.Item.prototype.clearTheListList = function() {
  return this.setTheListList([]);
};


/**
 * map<string, Item> the_map = 8;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,!proto.nnextractor.Item>}
 */
proto.nnextractor.Item.prototype.getTheMapMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,!proto.nnextractor.Item>} */ (
      jspb.Message.getMapField(this, 8, opt_noLazyCreate,
      proto.nnextractor.Item));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.nnextractor.Item} returns this
 */
proto.nnextractor.Item.prototype.clearTheMapMap = function() {
  this.getTheMapMap().clear();
  return this;
};


/**
 * optional OpItem op_item = 9;
 * @return {?proto.nnextractor.OpItem}
 */
proto.nnextractor.Item.prototype.getOpItem = function() {
  return /** @type{?proto.nnextractor.OpItem} */ (
    jspb.Message.getWrapperField(this, proto.nnextractor.OpItem, 9));
};


/**
 * @param {?proto.nnextractor.OpItem|undefined} value
 * @return {!proto.nnextractor.Item} returns this
*/
proto.nnextractor.Item.prototype.setOpItem = function(value) {
  return jspb.Message.setWrapperField(this, 9, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nnextractor.Item} returns this
 */
proto.nnextractor.Item.prototype.clearOpItem = function() {
  return this.setOpItem(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nnextractor.Item.prototype.hasOpItem = function() {
  return jspb.Message.getField(this, 9) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.nnextractor.Items.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nnextractor.Items.prototype.toObject = function(opt_includeInstance) {
  return proto.nnextractor.Items.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nnextractor.Items} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nnextractor.Items.toObject = function(includeInstance, msg) {
  var f, obj = {
name: jspb.Message.getFieldWithDefault(msg, 1, ""),
itemsList: jspb.Message.toObjectList(msg.getItemsList(),
    proto.nnextractor.Item.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nnextractor.Items}
 */
proto.nnextractor.Items.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nnextractor.Items;
  return proto.nnextractor.Items.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nnextractor.Items} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nnextractor.Items}
 */
proto.nnextractor.Items.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setName(value);
      break;
    case 2:
      var value = new proto.nnextractor.Item;
      reader.readMessage(value,proto.nnextractor.Item.deserializeBinaryFromReader);
      msg.addItems(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nnextractor.Items.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nnextractor.Items.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nnextractor.Items} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nnextractor.Items.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getName();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getItemsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.nnextractor.Item.serializeBinaryToWriter
    );
  }
};


/**
 * optional string name = 1;
 * @return {string}
 */
proto.nnextractor.Items.prototype.getName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.nnextractor.Items} returns this
 */
proto.nnextractor.Items.prototype.setName = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * repeated Item items = 2;
 * @return {!Array<!proto.nnextractor.Item>}
 */
proto.nnextractor.Items.prototype.getItemsList = function() {
  return /** @type{!Array<!proto.nnextractor.Item>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.nnextractor.Item, 2));
};


/**
 * @param {!Array<!proto.nnextractor.Item>} value
 * @return {!proto.nnextractor.Items} returns this
*/
proto.nnextractor.Items.prototype.setItemsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.nnextractor.Item=} opt_value
 * @param {number=} opt_index
 * @return {!proto.nnextractor.Item}
 */
proto.nnextractor.Items.prototype.addItems = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.nnextractor.Item, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nnextractor.Items} returns this
 */
proto.nnextractor.Items.prototype.clearItemsList = function() {
  return this.setItemsList([]);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.nnextractor.NNRecordMeta.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nnextractor.NNRecordMeta.prototype.toObject = function(opt_includeInstance) {
  return proto.nnextractor.NNRecordMeta.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nnextractor.NNRecordMeta} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nnextractor.NNRecordMeta.toObject = function(includeInstance, msg) {
  var f, obj = {
shapeList: (f = jspb.Message.getRepeatedField(msg, 1)) == null ? undefined : f,
theType: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nnextractor.NNRecordMeta}
 */
proto.nnextractor.NNRecordMeta.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nnextractor.NNRecordMeta;
  return proto.nnextractor.NNRecordMeta.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nnextractor.NNRecordMeta} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nnextractor.NNRecordMeta}
 */
proto.nnextractor.NNRecordMeta.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var values = /** @type {!Array<number>} */ (reader.isDelimited() ? reader.readPackedSint32() : [reader.readSint32()]);
      for (var i = 0; i < values.length; i++) {
        msg.addShape(values[i]);
      }
      break;
    case 2:
      var value = /** @type {!proto.nnextractor.NNTensorType} */ (reader.readEnum());
      msg.setTheType(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nnextractor.NNRecordMeta.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nnextractor.NNRecordMeta.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nnextractor.NNRecordMeta} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nnextractor.NNRecordMeta.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getShapeList();
  if (f.length > 0) {
    writer.writePackedSint32(
      1,
      f
    );
  }
  f = message.getTheType();
  if (f !== 0.0) {
    writer.writeEnum(
      2,
      f
    );
  }
};


/**
 * repeated sint32 shape = 1;
 * @return {!Array<number>}
 */
proto.nnextractor.NNRecordMeta.prototype.getShapeList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 1));
};


/**
 * @param {!Array<number>} value
 * @return {!proto.nnextractor.NNRecordMeta} returns this
 */
proto.nnextractor.NNRecordMeta.prototype.setShapeList = function(value) {
  return jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {number} value
 * @param {number=} opt_index
 * @return {!proto.nnextractor.NNRecordMeta} returns this
 */
proto.nnextractor.NNRecordMeta.prototype.addShape = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nnextractor.NNRecordMeta} returns this
 */
proto.nnextractor.NNRecordMeta.prototype.clearShapeList = function() {
  return this.setShapeList([]);
};


/**
 * optional NNTensorType the_type = 2;
 * @return {!proto.nnextractor.NNTensorType}
 */
proto.nnextractor.NNRecordMeta.prototype.getTheType = function() {
  return /** @type {!proto.nnextractor.NNTensorType} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {!proto.nnextractor.NNTensorType} value
 * @return {!proto.nnextractor.NNRecordMeta} returns this
 */
proto.nnextractor.NNRecordMeta.prototype.setTheType = function(value) {
  return jspb.Message.setProto3EnumField(this, 2, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.nnextractor.NNRecord.repeatedFields_ = [4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nnextractor.NNRecord.prototype.toObject = function(opt_includeInstance) {
  return proto.nnextractor.NNRecord.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nnextractor.NNRecord} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nnextractor.NNRecord.toObject = function(includeInstance, msg) {
  var f, obj = {
name: (f = jspb.Message.getField(msg, 1)) == null ? undefined : f,
theType: jspb.Message.getFieldWithDefault(msg, 2, 0),
tensor: (f = msg.getTensor()) && proto.nnextractor.NNTensor.toObject(includeInstance, f),
recordsList: jspb.Message.toObjectList(msg.getRecordsList(),
    proto.nnextractor.NNRecord.toObject, includeInstance),
theMapMap: (f = msg.getTheMapMap()) ? f.toObject(includeInstance, proto.nnextractor.NNRecord.toObject) : [],
meta: (f = msg.getMeta()) && proto.nnextractor.NNRecordMeta.toObject(includeInstance, f),
opType: (f = jspb.Message.getField(msg, 7)) == null ? undefined : f,
opParams: (f = msg.getOpParams()) && proto.nnextractor.Item.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nnextractor.NNRecord}
 */
proto.nnextractor.NNRecord.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nnextractor.NNRecord;
  return proto.nnextractor.NNRecord.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nnextractor.NNRecord} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nnextractor.NNRecord}
 */
proto.nnextractor.NNRecord.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setName(value);
      break;
    case 2:
      var value = /** @type {!proto.nnextractor.NNRecordType} */ (reader.readEnum());
      msg.setTheType(value);
      break;
    case 3:
      var value = new proto.nnextractor.NNTensor;
      reader.readMessage(value,proto.nnextractor.NNTensor.deserializeBinaryFromReader);
      msg.setTensor(value);
      break;
    case 4:
      var value = new proto.nnextractor.NNRecord;
      reader.readMessage(value,proto.nnextractor.NNRecord.deserializeBinaryFromReader);
      msg.addRecords(value);
      break;
    case 5:
      var value = msg.getTheMapMap();
      reader.readMessage(value, function(message, reader) {
        jspb.Map.deserializeBinary(message, reader, jspb.BinaryReader.prototype.readString, jspb.BinaryReader.prototype.readMessage, proto.nnextractor.NNRecord.deserializeBinaryFromReader, "", new proto.nnextractor.NNRecord());
         });
      break;
    case 6:
      var value = new proto.nnextractor.NNRecordMeta;
      reader.readMessage(value,proto.nnextractor.NNRecordMeta.deserializeBinaryFromReader);
      msg.setMeta(value);
      break;
    case 7:
      var value = /** @type {!proto.nnextractor.OpType} */ (reader.readEnum());
      msg.setOpType(value);
      break;
    case 8:
      var value = new proto.nnextractor.Item;
      reader.readMessage(value,proto.nnextractor.Item.deserializeBinaryFromReader);
      msg.setOpParams(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nnextractor.NNRecord.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nnextractor.NNRecord.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nnextractor.NNRecord} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nnextractor.NNRecord.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getTheType();
  if (f !== 0.0) {
    writer.writeEnum(
      2,
      f
    );
  }
  f = message.getTensor();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.nnextractor.NNTensor.serializeBinaryToWriter
    );
  }
  f = message.getRecordsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.nnextractor.NNRecord.serializeBinaryToWriter
    );
  }
  f = message.getTheMapMap(true);
  if (f && f.getLength() > 0) {
    f.serializeBinary(5, writer, jspb.BinaryWriter.prototype.writeString, jspb.BinaryWriter.prototype.writeMessage, proto.nnextractor.NNRecord.serializeBinaryToWriter);
  }
  f = message.getMeta();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.nnextractor.NNRecordMeta.serializeBinaryToWriter
    );
  }
  f = /** @type {!proto.nnextractor.OpType} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeEnum(
      7,
      f
    );
  }
  f = message.getOpParams();
  if (f != null) {
    writer.writeMessage(
      8,
      f,
      proto.nnextractor.Item.serializeBinaryToWriter
    );
  }
};


/**
 * optional string name = 1;
 * @return {string}
 */
proto.nnextractor.NNRecord.prototype.getName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.nnextractor.NNRecord} returns this
 */
proto.nnextractor.NNRecord.prototype.setName = function(value) {
  return jspb.Message.setField(this, 1, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.nnextractor.NNRecord} returns this
 */
proto.nnextractor.NNRecord.prototype.clearName = function() {
  return jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nnextractor.NNRecord.prototype.hasName = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional NNRecordType the_type = 2;
 * @return {!proto.nnextractor.NNRecordType}
 */
proto.nnextractor.NNRecord.prototype.getTheType = function() {
  return /** @type {!proto.nnextractor.NNRecordType} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {!proto.nnextractor.NNRecordType} value
 * @return {!proto.nnextractor.NNRecord} returns this
 */
proto.nnextractor.NNRecord.prototype.setTheType = function(value) {
  return jspb.Message.setProto3EnumField(this, 2, value);
};


/**
 * optional NNTensor tensor = 3;
 * @return {?proto.nnextractor.NNTensor}
 */
proto.nnextractor.NNRecord.prototype.getTensor = function() {
  return /** @type{?proto.nnextractor.NNTensor} */ (
    jspb.Message.getWrapperField(this, proto.nnextractor.NNTensor, 3));
};


/**
 * @param {?proto.nnextractor.NNTensor|undefined} value
 * @return {!proto.nnextractor.NNRecord} returns this
*/
proto.nnextractor.NNRecord.prototype.setTensor = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nnextractor.NNRecord} returns this
 */
proto.nnextractor.NNRecord.prototype.clearTensor = function() {
  return this.setTensor(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nnextractor.NNRecord.prototype.hasTensor = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * repeated NNRecord records = 4;
 * @return {!Array<!proto.nnextractor.NNRecord>}
 */
proto.nnextractor.NNRecord.prototype.getRecordsList = function() {
  return /** @type{!Array<!proto.nnextractor.NNRecord>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.nnextractor.NNRecord, 4));
};


/**
 * @param {!Array<!proto.nnextractor.NNRecord>} value
 * @return {!proto.nnextractor.NNRecord} returns this
*/
proto.nnextractor.NNRecord.prototype.setRecordsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.nnextractor.NNRecord=} opt_value
 * @param {number=} opt_index
 * @return {!proto.nnextractor.NNRecord}
 */
proto.nnextractor.NNRecord.prototype.addRecords = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.nnextractor.NNRecord, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nnextractor.NNRecord} returns this
 */
proto.nnextractor.NNRecord.prototype.clearRecordsList = function() {
  return this.setRecordsList([]);
};


/**
 * map<string, NNRecord> the_map = 5;
 * @param {boolean=} opt_noLazyCreate Do not create the map if
 * empty, instead returning `undefined`
 * @return {!jspb.Map<string,!proto.nnextractor.NNRecord>}
 */
proto.nnextractor.NNRecord.prototype.getTheMapMap = function(opt_noLazyCreate) {
  return /** @type {!jspb.Map<string,!proto.nnextractor.NNRecord>} */ (
      jspb.Message.getMapField(this, 5, opt_noLazyCreate,
      proto.nnextractor.NNRecord));
};


/**
 * Clears values from the map. The map will be non-null.
 * @return {!proto.nnextractor.NNRecord} returns this
 */
proto.nnextractor.NNRecord.prototype.clearTheMapMap = function() {
  this.getTheMapMap().clear();
  return this;
};


/**
 * optional NNRecordMeta meta = 6;
 * @return {?proto.nnextractor.NNRecordMeta}
 */
proto.nnextractor.NNRecord.prototype.getMeta = function() {
  return /** @type{?proto.nnextractor.NNRecordMeta} */ (
    jspb.Message.getWrapperField(this, proto.nnextractor.NNRecordMeta, 6));
};


/**
 * @param {?proto.nnextractor.NNRecordMeta|undefined} value
 * @return {!proto.nnextractor.NNRecord} returns this
*/
proto.nnextractor.NNRecord.prototype.setMeta = function(value) {
  return jspb.Message.setWrapperField(this, 6, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nnextractor.NNRecord} returns this
 */
proto.nnextractor.NNRecord.prototype.clearMeta = function() {
  return this.setMeta(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nnextractor.NNRecord.prototype.hasMeta = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional OpType op_type = 7;
 * @return {!proto.nnextractor.OpType}
 */
proto.nnextractor.NNRecord.prototype.getOpType = function() {
  return /** @type {!proto.nnextractor.OpType} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/**
 * @param {!proto.nnextractor.OpType} value
 * @return {!proto.nnextractor.NNRecord} returns this
 */
proto.nnextractor.NNRecord.prototype.setOpType = function(value) {
  return jspb.Message.setField(this, 7, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.nnextractor.NNRecord} returns this
 */
proto.nnextractor.NNRecord.prototype.clearOpType = function() {
  return jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nnextractor.NNRecord.prototype.hasOpType = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional Item op_params = 8;
 * @return {?proto.nnextractor.Item}
 */
proto.nnextractor.NNRecord.prototype.getOpParams = function() {
  return /** @type{?proto.nnextractor.Item} */ (
    jspb.Message.getWrapperField(this, proto.nnextractor.Item, 8));
};


/**
 * @param {?proto.nnextractor.Item|undefined} value
 * @return {!proto.nnextractor.NNRecord} returns this
*/
proto.nnextractor.NNRecord.prototype.setOpParams = function(value) {
  return jspb.Message.setWrapperField(this, 8, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nnextractor.NNRecord} returns this
 */
proto.nnextractor.NNRecord.prototype.clearOpParams = function() {
  return this.setOpParams(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nnextractor.NNRecord.prototype.hasOpParams = function() {
  return jspb.Message.getField(this, 8) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nnextractor.NNParameter.prototype.toObject = function(opt_includeInstance) {
  return proto.nnextractor.NNParameter.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nnextractor.NNParameter} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nnextractor.NNParameter.toObject = function(includeInstance, msg) {
  var f, obj = {
name: jspb.Message.getFieldWithDefault(msg, 1, ""),
parameter: (f = msg.getParameter()) && proto.nnextractor.NNRecord.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nnextractor.NNParameter}
 */
proto.nnextractor.NNParameter.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nnextractor.NNParameter;
  return proto.nnextractor.NNParameter.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nnextractor.NNParameter} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nnextractor.NNParameter}
 */
proto.nnextractor.NNParameter.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setName(value);
      break;
    case 2:
      var value = new proto.nnextractor.NNRecord;
      reader.readMessage(value,proto.nnextractor.NNRecord.deserializeBinaryFromReader);
      msg.setParameter(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nnextractor.NNParameter.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nnextractor.NNParameter.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nnextractor.NNParameter} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nnextractor.NNParameter.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getName();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getParameter();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.nnextractor.NNRecord.serializeBinaryToWriter
    );
  }
};


/**
 * optional string name = 1;
 * @return {string}
 */
proto.nnextractor.NNParameter.prototype.getName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.nnextractor.NNParameter} returns this
 */
proto.nnextractor.NNParameter.prototype.setName = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional NNRecord parameter = 2;
 * @return {?proto.nnextractor.NNRecord}
 */
proto.nnextractor.NNParameter.prototype.getParameter = function() {
  return /** @type{?proto.nnextractor.NNRecord} */ (
    jspb.Message.getWrapperField(this, proto.nnextractor.NNRecord, 2));
};


/**
 * @param {?proto.nnextractor.NNRecord|undefined} value
 * @return {!proto.nnextractor.NNParameter} returns this
*/
proto.nnextractor.NNParameter.prototype.setParameter = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nnextractor.NNParameter} returns this
 */
proto.nnextractor.NNParameter.prototype.clearParameter = function() {
  return this.setParameter(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nnextractor.NNParameter.prototype.hasParameter = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.nnextractor.NNNode.repeatedFields_ = [2,3,5,6,7,8];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nnextractor.NNNode.prototype.toObject = function(opt_includeInstance) {
  return proto.nnextractor.NNNode.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nnextractor.NNNode} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nnextractor.NNNode.toObject = function(includeInstance, msg) {
  var f, obj = {
name: jspb.Message.getFieldWithDefault(msg, 1, ""),
inputsList: jspb.Message.toObjectList(msg.getInputsList(),
    proto.nnextractor.NNRecord.toObject, includeInstance),
paramsList: jspb.Message.toObjectList(msg.getParamsList(),
    proto.nnextractor.NNParameter.toObject, includeInstance),
activation: (f = msg.getActivation()) && proto.nnextractor.NNRecord.toObject(includeInstance, f),
gradientInputsList: jspb.Message.toObjectList(msg.getGradientInputsList(),
    proto.nnextractor.NNRecord.toObject, includeInstance),
gradientParamsList: jspb.Message.toObjectList(msg.getGradientParamsList(),
    proto.nnextractor.NNParameter.toObject, includeInstance),
gradientsList: jspb.Message.toObjectList(msg.getGradientsList(),
    proto.nnextractor.NNRecord.toObject, includeInstance),
childrenList: jspb.Message.toObjectList(msg.getChildrenList(),
    proto.nnextractor.NNNode.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nnextractor.NNNode}
 */
proto.nnextractor.NNNode.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nnextractor.NNNode;
  return proto.nnextractor.NNNode.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nnextractor.NNNode} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nnextractor.NNNode}
 */
proto.nnextractor.NNNode.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setName(value);
      break;
    case 2:
      var value = new proto.nnextractor.NNRecord;
      reader.readMessage(value,proto.nnextractor.NNRecord.deserializeBinaryFromReader);
      msg.addInputs(value);
      break;
    case 3:
      var value = new proto.nnextractor.NNParameter;
      reader.readMessage(value,proto.nnextractor.NNParameter.deserializeBinaryFromReader);
      msg.addParams(value);
      break;
    case 4:
      var value = new proto.nnextractor.NNRecord;
      reader.readMessage(value,proto.nnextractor.NNRecord.deserializeBinaryFromReader);
      msg.setActivation(value);
      break;
    case 5:
      var value = new proto.nnextractor.NNRecord;
      reader.readMessage(value,proto.nnextractor.NNRecord.deserializeBinaryFromReader);
      msg.addGradientInputs(value);
      break;
    case 6:
      var value = new proto.nnextractor.NNParameter;
      reader.readMessage(value,proto.nnextractor.NNParameter.deserializeBinaryFromReader);
      msg.addGradientParams(value);
      break;
    case 7:
      var value = new proto.nnextractor.NNRecord;
      reader.readMessage(value,proto.nnextractor.NNRecord.deserializeBinaryFromReader);
      msg.addGradients(value);
      break;
    case 8:
      var value = new proto.nnextractor.NNNode;
      reader.readMessage(value,proto.nnextractor.NNNode.deserializeBinaryFromReader);
      msg.addChildren(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nnextractor.NNNode.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nnextractor.NNNode.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nnextractor.NNNode} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nnextractor.NNNode.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getName();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getInputsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.nnextractor.NNRecord.serializeBinaryToWriter
    );
  }
  f = message.getParamsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.nnextractor.NNParameter.serializeBinaryToWriter
    );
  }
  f = message.getActivation();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.nnextractor.NNRecord.serializeBinaryToWriter
    );
  }
  f = message.getGradientInputsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      5,
      f,
      proto.nnextractor.NNRecord.serializeBinaryToWriter
    );
  }
  f = message.getGradientParamsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      6,
      f,
      proto.nnextractor.NNParameter.serializeBinaryToWriter
    );
  }
  f = message.getGradientsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      7,
      f,
      proto.nnextractor.NNRecord.serializeBinaryToWriter
    );
  }
  f = message.getChildrenList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      8,
      f,
      proto.nnextractor.NNNode.serializeBinaryToWriter
    );
  }
};


/**
 * optional string name = 1;
 * @return {string}
 */
proto.nnextractor.NNNode.prototype.getName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.nnextractor.NNNode} returns this
 */
proto.nnextractor.NNNode.prototype.setName = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * repeated NNRecord inputs = 2;
 * @return {!Array<!proto.nnextractor.NNRecord>}
 */
proto.nnextractor.NNNode.prototype.getInputsList = function() {
  return /** @type{!Array<!proto.nnextractor.NNRecord>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.nnextractor.NNRecord, 2));
};


/**
 * @param {!Array<!proto.nnextractor.NNRecord>} value
 * @return {!proto.nnextractor.NNNode} returns this
*/
proto.nnextractor.NNNode.prototype.setInputsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.nnextractor.NNRecord=} opt_value
 * @param {number=} opt_index
 * @return {!proto.nnextractor.NNRecord}
 */
proto.nnextractor.NNNode.prototype.addInputs = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.nnextractor.NNRecord, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nnextractor.NNNode} returns this
 */
proto.nnextractor.NNNode.prototype.clearInputsList = function() {
  return this.setInputsList([]);
};


/**
 * repeated NNParameter params = 3;
 * @return {!Array<!proto.nnextractor.NNParameter>}
 */
proto.nnextractor.NNNode.prototype.getParamsList = function() {
  return /** @type{!Array<!proto.nnextractor.NNParameter>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.nnextractor.NNParameter, 3));
};


/**
 * @param {!Array<!proto.nnextractor.NNParameter>} value
 * @return {!proto.nnextractor.NNNode} returns this
*/
proto.nnextractor.NNNode.prototype.setParamsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.nnextractor.NNParameter=} opt_value
 * @param {number=} opt_index
 * @return {!proto.nnextractor.NNParameter}
 */
proto.nnextractor.NNNode.prototype.addParams = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.nnextractor.NNParameter, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nnextractor.NNNode} returns this
 */
proto.nnextractor.NNNode.prototype.clearParamsList = function() {
  return this.setParamsList([]);
};


/**
 * optional NNRecord activation = 4;
 * @return {?proto.nnextractor.NNRecord}
 */
proto.nnextractor.NNNode.prototype.getActivation = function() {
  return /** @type{?proto.nnextractor.NNRecord} */ (
    jspb.Message.getWrapperField(this, proto.nnextractor.NNRecord, 4));
};


/**
 * @param {?proto.nnextractor.NNRecord|undefined} value
 * @return {!proto.nnextractor.NNNode} returns this
*/
proto.nnextractor.NNNode.prototype.setActivation = function(value) {
  return jspb.Message.setWrapperField(this, 4, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.nnextractor.NNNode} returns this
 */
proto.nnextractor.NNNode.prototype.clearActivation = function() {
  return this.setActivation(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nnextractor.NNNode.prototype.hasActivation = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * repeated NNRecord gradient_inputs = 5;
 * @return {!Array<!proto.nnextractor.NNRecord>}
 */
proto.nnextractor.NNNode.prototype.getGradientInputsList = function() {
  return /** @type{!Array<!proto.nnextractor.NNRecord>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.nnextractor.NNRecord, 5));
};


/**
 * @param {!Array<!proto.nnextractor.NNRecord>} value
 * @return {!proto.nnextractor.NNNode} returns this
*/
proto.nnextractor.NNNode.prototype.setGradientInputsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 5, value);
};


/**
 * @param {!proto.nnextractor.NNRecord=} opt_value
 * @param {number=} opt_index
 * @return {!proto.nnextractor.NNRecord}
 */
proto.nnextractor.NNNode.prototype.addGradientInputs = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 5, opt_value, proto.nnextractor.NNRecord, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nnextractor.NNNode} returns this
 */
proto.nnextractor.NNNode.prototype.clearGradientInputsList = function() {
  return this.setGradientInputsList([]);
};


/**
 * repeated NNParameter gradient_params = 6;
 * @return {!Array<!proto.nnextractor.NNParameter>}
 */
proto.nnextractor.NNNode.prototype.getGradientParamsList = function() {
  return /** @type{!Array<!proto.nnextractor.NNParameter>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.nnextractor.NNParameter, 6));
};


/**
 * @param {!Array<!proto.nnextractor.NNParameter>} value
 * @return {!proto.nnextractor.NNNode} returns this
*/
proto.nnextractor.NNNode.prototype.setGradientParamsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 6, value);
};


/**
 * @param {!proto.nnextractor.NNParameter=} opt_value
 * @param {number=} opt_index
 * @return {!proto.nnextractor.NNParameter}
 */
proto.nnextractor.NNNode.prototype.addGradientParams = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 6, opt_value, proto.nnextractor.NNParameter, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nnextractor.NNNode} returns this
 */
proto.nnextractor.NNNode.prototype.clearGradientParamsList = function() {
  return this.setGradientParamsList([]);
};


/**
 * repeated NNRecord gradients = 7;
 * @return {!Array<!proto.nnextractor.NNRecord>}
 */
proto.nnextractor.NNNode.prototype.getGradientsList = function() {
  return /** @type{!Array<!proto.nnextractor.NNRecord>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.nnextractor.NNRecord, 7));
};


/**
 * @param {!Array<!proto.nnextractor.NNRecord>} value
 * @return {!proto.nnextractor.NNNode} returns this
*/
proto.nnextractor.NNNode.prototype.setGradientsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 7, value);
};


/**
 * @param {!proto.nnextractor.NNRecord=} opt_value
 * @param {number=} opt_index
 * @return {!proto.nnextractor.NNRecord}
 */
proto.nnextractor.NNNode.prototype.addGradients = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 7, opt_value, proto.nnextractor.NNRecord, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nnextractor.NNNode} returns this
 */
proto.nnextractor.NNNode.prototype.clearGradientsList = function() {
  return this.setGradientsList([]);
};


/**
 * repeated NNNode children = 8;
 * @return {!Array<!proto.nnextractor.NNNode>}
 */
proto.nnextractor.NNNode.prototype.getChildrenList = function() {
  return /** @type{!Array<!proto.nnextractor.NNNode>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.nnextractor.NNNode, 8));
};


/**
 * @param {!Array<!proto.nnextractor.NNNode>} value
 * @return {!proto.nnextractor.NNNode} returns this
*/
proto.nnextractor.NNNode.prototype.setChildrenList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 8, value);
};


/**
 * @param {!proto.nnextractor.NNNode=} opt_value
 * @param {number=} opt_index
 * @return {!proto.nnextractor.NNNode}
 */
proto.nnextractor.NNNode.prototype.addChildren = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 8, opt_value, proto.nnextractor.NNNode, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nnextractor.NNNode} returns this
 */
proto.nnextractor.NNNode.prototype.clearChildrenList = function() {
  return this.setChildrenList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nnextractor.Taskflow.prototype.toObject = function(opt_includeInstance) {
  return proto.nnextractor.Taskflow.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nnextractor.Taskflow} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nnextractor.Taskflow.toObject = function(includeInstance, msg) {
  var f, obj = {
theType: jspb.Message.getFieldWithDefault(msg, 1, 0),
flowId: jspb.Message.getFieldWithDefault(msg, 2, 0),
name: (f = jspb.Message.getField(msg, 3)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nnextractor.Taskflow}
 */
proto.nnextractor.Taskflow.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nnextractor.Taskflow;
  return proto.nnextractor.Taskflow.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nnextractor.Taskflow} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nnextractor.Taskflow}
 */
proto.nnextractor.Taskflow.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.nnextractor.TaskflowType} */ (reader.readEnum());
      msg.setTheType(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setFlowId(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setName(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nnextractor.Taskflow.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nnextractor.Taskflow.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nnextractor.Taskflow} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nnextractor.Taskflow.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTheType();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getFlowId();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeString(
      3,
      f
    );
  }
};


/**
 * optional TaskflowType the_type = 1;
 * @return {!proto.nnextractor.TaskflowType}
 */
proto.nnextractor.Taskflow.prototype.getTheType = function() {
  return /** @type {!proto.nnextractor.TaskflowType} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {!proto.nnextractor.TaskflowType} value
 * @return {!proto.nnextractor.Taskflow} returns this
 */
proto.nnextractor.Taskflow.prototype.setTheType = function(value) {
  return jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional int64 flow_id = 2;
 * @return {number}
 */
proto.nnextractor.Taskflow.prototype.getFlowId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.nnextractor.Taskflow} returns this
 */
proto.nnextractor.Taskflow.prototype.setFlowId = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional string name = 3;
 * @return {string}
 */
proto.nnextractor.Taskflow.prototype.getName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.nnextractor.Taskflow} returns this
 */
proto.nnextractor.Taskflow.prototype.setName = function(value) {
  return jspb.Message.setField(this, 3, value);
};


/**
 * Clears the field making it undefined.
 * @return {!proto.nnextractor.Taskflow} returns this
 */
proto.nnextractor.Taskflow.prototype.clearName = function() {
  return jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.nnextractor.Taskflow.prototype.hasName = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.nnextractor.NNExtractor.repeatedFields_ = [2,3,4,5,6,7,8,9,10];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.nnextractor.NNExtractor.prototype.toObject = function(opt_includeInstance) {
  return proto.nnextractor.NNExtractor.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.nnextractor.NNExtractor} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nnextractor.NNExtractor.toObject = function(includeInstance, msg) {
  var f, obj = {
name: jspb.Message.getFieldWithDefault(msg, 1, ""),
taskflowList: jspb.Message.toObjectList(msg.getTaskflowList(),
    proto.nnextractor.Taskflow.toObject, includeInstance),
inputsList: jspb.Message.toObjectList(msg.getInputsList(),
    proto.nnextractor.Items.toObject, includeInstance),
preprocessesList: jspb.Message.toObjectList(msg.getPreprocessesList(),
    proto.nnextractor.Items.toObject, includeInstance),
nodesList: jspb.Message.toObjectList(msg.getNodesList(),
    proto.nnextractor.NNNode.toObject, includeInstance),
postprocessesList: jspb.Message.toObjectList(msg.getPostprocessesList(),
    proto.nnextractor.Items.toObject, includeInstance),
outputsList: jspb.Message.toObjectList(msg.getOutputsList(),
    proto.nnextractor.Items.toObject, includeInstance),
forwardsList: jspb.Message.toObjectList(msg.getForwardsList(),
    proto.nnextractor.NNNode.toObject, includeInstance),
backwardsList: jspb.Message.toObjectList(msg.getBackwardsList(),
    proto.nnextractor.NNNode.toObject, includeInstance),
extractorsList: jspb.Message.toObjectList(msg.getExtractorsList(),
    proto.nnextractor.NNExtractor.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.nnextractor.NNExtractor}
 */
proto.nnextractor.NNExtractor.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.nnextractor.NNExtractor;
  return proto.nnextractor.NNExtractor.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.nnextractor.NNExtractor} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.nnextractor.NNExtractor}
 */
proto.nnextractor.NNExtractor.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setName(value);
      break;
    case 2:
      var value = new proto.nnextractor.Taskflow;
      reader.readMessage(value,proto.nnextractor.Taskflow.deserializeBinaryFromReader);
      msg.addTaskflow(value);
      break;
    case 3:
      var value = new proto.nnextractor.Items;
      reader.readMessage(value,proto.nnextractor.Items.deserializeBinaryFromReader);
      msg.addInputs(value);
      break;
    case 4:
      var value = new proto.nnextractor.Items;
      reader.readMessage(value,proto.nnextractor.Items.deserializeBinaryFromReader);
      msg.addPreprocesses(value);
      break;
    case 5:
      var value = new proto.nnextractor.NNNode;
      reader.readMessage(value,proto.nnextractor.NNNode.deserializeBinaryFromReader);
      msg.addNodes(value);
      break;
    case 6:
      var value = new proto.nnextractor.Items;
      reader.readMessage(value,proto.nnextractor.Items.deserializeBinaryFromReader);
      msg.addPostprocesses(value);
      break;
    case 7:
      var value = new proto.nnextractor.Items;
      reader.readMessage(value,proto.nnextractor.Items.deserializeBinaryFromReader);
      msg.addOutputs(value);
      break;
    case 8:
      var value = new proto.nnextractor.NNNode;
      reader.readMessage(value,proto.nnextractor.NNNode.deserializeBinaryFromReader);
      msg.addForwards(value);
      break;
    case 9:
      var value = new proto.nnextractor.NNNode;
      reader.readMessage(value,proto.nnextractor.NNNode.deserializeBinaryFromReader);
      msg.addBackwards(value);
      break;
    case 10:
      var value = new proto.nnextractor.NNExtractor;
      reader.readMessage(value,proto.nnextractor.NNExtractor.deserializeBinaryFromReader);
      msg.addExtractors(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.nnextractor.NNExtractor.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.nnextractor.NNExtractor.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.nnextractor.NNExtractor} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.nnextractor.NNExtractor.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getName();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getTaskflowList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.nnextractor.Taskflow.serializeBinaryToWriter
    );
  }
  f = message.getInputsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.nnextractor.Items.serializeBinaryToWriter
    );
  }
  f = message.getPreprocessesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.nnextractor.Items.serializeBinaryToWriter
    );
  }
  f = message.getNodesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      5,
      f,
      proto.nnextractor.NNNode.serializeBinaryToWriter
    );
  }
  f = message.getPostprocessesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      6,
      f,
      proto.nnextractor.Items.serializeBinaryToWriter
    );
  }
  f = message.getOutputsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      7,
      f,
      proto.nnextractor.Items.serializeBinaryToWriter
    );
  }
  f = message.getForwardsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      8,
      f,
      proto.nnextractor.NNNode.serializeBinaryToWriter
    );
  }
  f = message.getBackwardsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      9,
      f,
      proto.nnextractor.NNNode.serializeBinaryToWriter
    );
  }
  f = message.getExtractorsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      10,
      f,
      proto.nnextractor.NNExtractor.serializeBinaryToWriter
    );
  }
};


/**
 * optional string name = 1;
 * @return {string}
 */
proto.nnextractor.NNExtractor.prototype.getName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.nnextractor.NNExtractor} returns this
 */
proto.nnextractor.NNExtractor.prototype.setName = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * repeated Taskflow taskflow = 2;
 * @return {!Array<!proto.nnextractor.Taskflow>}
 */
proto.nnextractor.NNExtractor.prototype.getTaskflowList = function() {
  return /** @type{!Array<!proto.nnextractor.Taskflow>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.nnextractor.Taskflow, 2));
};


/**
 * @param {!Array<!proto.nnextractor.Taskflow>} value
 * @return {!proto.nnextractor.NNExtractor} returns this
*/
proto.nnextractor.NNExtractor.prototype.setTaskflowList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.nnextractor.Taskflow=} opt_value
 * @param {number=} opt_index
 * @return {!proto.nnextractor.Taskflow}
 */
proto.nnextractor.NNExtractor.prototype.addTaskflow = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.nnextractor.Taskflow, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nnextractor.NNExtractor} returns this
 */
proto.nnextractor.NNExtractor.prototype.clearTaskflowList = function() {
  return this.setTaskflowList([]);
};


/**
 * repeated Items inputs = 3;
 * @return {!Array<!proto.nnextractor.Items>}
 */
proto.nnextractor.NNExtractor.prototype.getInputsList = function() {
  return /** @type{!Array<!proto.nnextractor.Items>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.nnextractor.Items, 3));
};


/**
 * @param {!Array<!proto.nnextractor.Items>} value
 * @return {!proto.nnextractor.NNExtractor} returns this
*/
proto.nnextractor.NNExtractor.prototype.setInputsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.nnextractor.Items=} opt_value
 * @param {number=} opt_index
 * @return {!proto.nnextractor.Items}
 */
proto.nnextractor.NNExtractor.prototype.addInputs = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.nnextractor.Items, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nnextractor.NNExtractor} returns this
 */
proto.nnextractor.NNExtractor.prototype.clearInputsList = function() {
  return this.setInputsList([]);
};


/**
 * repeated Items preprocesses = 4;
 * @return {!Array<!proto.nnextractor.Items>}
 */
proto.nnextractor.NNExtractor.prototype.getPreprocessesList = function() {
  return /** @type{!Array<!proto.nnextractor.Items>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.nnextractor.Items, 4));
};


/**
 * @param {!Array<!proto.nnextractor.Items>} value
 * @return {!proto.nnextractor.NNExtractor} returns this
*/
proto.nnextractor.NNExtractor.prototype.setPreprocessesList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.nnextractor.Items=} opt_value
 * @param {number=} opt_index
 * @return {!proto.nnextractor.Items}
 */
proto.nnextractor.NNExtractor.prototype.addPreprocesses = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.nnextractor.Items, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nnextractor.NNExtractor} returns this
 */
proto.nnextractor.NNExtractor.prototype.clearPreprocessesList = function() {
  return this.setPreprocessesList([]);
};


/**
 * repeated NNNode nodes = 5;
 * @return {!Array<!proto.nnextractor.NNNode>}
 */
proto.nnextractor.NNExtractor.prototype.getNodesList = function() {
  return /** @type{!Array<!proto.nnextractor.NNNode>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.nnextractor.NNNode, 5));
};


/**
 * @param {!Array<!proto.nnextractor.NNNode>} value
 * @return {!proto.nnextractor.NNExtractor} returns this
*/
proto.nnextractor.NNExtractor.prototype.setNodesList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 5, value);
};


/**
 * @param {!proto.nnextractor.NNNode=} opt_value
 * @param {number=} opt_index
 * @return {!proto.nnextractor.NNNode}
 */
proto.nnextractor.NNExtractor.prototype.addNodes = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 5, opt_value, proto.nnextractor.NNNode, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nnextractor.NNExtractor} returns this
 */
proto.nnextractor.NNExtractor.prototype.clearNodesList = function() {
  return this.setNodesList([]);
};


/**
 * repeated Items postprocesses = 6;
 * @return {!Array<!proto.nnextractor.Items>}
 */
proto.nnextractor.NNExtractor.prototype.getPostprocessesList = function() {
  return /** @type{!Array<!proto.nnextractor.Items>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.nnextractor.Items, 6));
};


/**
 * @param {!Array<!proto.nnextractor.Items>} value
 * @return {!proto.nnextractor.NNExtractor} returns this
*/
proto.nnextractor.NNExtractor.prototype.setPostprocessesList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 6, value);
};


/**
 * @param {!proto.nnextractor.Items=} opt_value
 * @param {number=} opt_index
 * @return {!proto.nnextractor.Items}
 */
proto.nnextractor.NNExtractor.prototype.addPostprocesses = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 6, opt_value, proto.nnextractor.Items, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nnextractor.NNExtractor} returns this
 */
proto.nnextractor.NNExtractor.prototype.clearPostprocessesList = function() {
  return this.setPostprocessesList([]);
};


/**
 * repeated Items outputs = 7;
 * @return {!Array<!proto.nnextractor.Items>}
 */
proto.nnextractor.NNExtractor.prototype.getOutputsList = function() {
  return /** @type{!Array<!proto.nnextractor.Items>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.nnextractor.Items, 7));
};


/**
 * @param {!Array<!proto.nnextractor.Items>} value
 * @return {!proto.nnextractor.NNExtractor} returns this
*/
proto.nnextractor.NNExtractor.prototype.setOutputsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 7, value);
};


/**
 * @param {!proto.nnextractor.Items=} opt_value
 * @param {number=} opt_index
 * @return {!proto.nnextractor.Items}
 */
proto.nnextractor.NNExtractor.prototype.addOutputs = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 7, opt_value, proto.nnextractor.Items, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nnextractor.NNExtractor} returns this
 */
proto.nnextractor.NNExtractor.prototype.clearOutputsList = function() {
  return this.setOutputsList([]);
};


/**
 * repeated NNNode forwards = 8;
 * @return {!Array<!proto.nnextractor.NNNode>}
 */
proto.nnextractor.NNExtractor.prototype.getForwardsList = function() {
  return /** @type{!Array<!proto.nnextractor.NNNode>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.nnextractor.NNNode, 8));
};


/**
 * @param {!Array<!proto.nnextractor.NNNode>} value
 * @return {!proto.nnextractor.NNExtractor} returns this
*/
proto.nnextractor.NNExtractor.prototype.setForwardsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 8, value);
};


/**
 * @param {!proto.nnextractor.NNNode=} opt_value
 * @param {number=} opt_index
 * @return {!proto.nnextractor.NNNode}
 */
proto.nnextractor.NNExtractor.prototype.addForwards = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 8, opt_value, proto.nnextractor.NNNode, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nnextractor.NNExtractor} returns this
 */
proto.nnextractor.NNExtractor.prototype.clearForwardsList = function() {
  return this.setForwardsList([]);
};


/**
 * repeated NNNode backwards = 9;
 * @return {!Array<!proto.nnextractor.NNNode>}
 */
proto.nnextractor.NNExtractor.prototype.getBackwardsList = function() {
  return /** @type{!Array<!proto.nnextractor.NNNode>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.nnextractor.NNNode, 9));
};


/**
 * @param {!Array<!proto.nnextractor.NNNode>} value
 * @return {!proto.nnextractor.NNExtractor} returns this
*/
proto.nnextractor.NNExtractor.prototype.setBackwardsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 9, value);
};


/**
 * @param {!proto.nnextractor.NNNode=} opt_value
 * @param {number=} opt_index
 * @return {!proto.nnextractor.NNNode}
 */
proto.nnextractor.NNExtractor.prototype.addBackwards = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 9, opt_value, proto.nnextractor.NNNode, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nnextractor.NNExtractor} returns this
 */
proto.nnextractor.NNExtractor.prototype.clearBackwardsList = function() {
  return this.setBackwardsList([]);
};


/**
 * repeated NNExtractor extractors = 10;
 * @return {!Array<!proto.nnextractor.NNExtractor>}
 */
proto.nnextractor.NNExtractor.prototype.getExtractorsList = function() {
  return /** @type{!Array<!proto.nnextractor.NNExtractor>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.nnextractor.NNExtractor, 10));
};


/**
 * @param {!Array<!proto.nnextractor.NNExtractor>} value
 * @return {!proto.nnextractor.NNExtractor} returns this
*/
proto.nnextractor.NNExtractor.prototype.setExtractorsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 10, value);
};


/**
 * @param {!proto.nnextractor.NNExtractor=} opt_value
 * @param {number=} opt_index
 * @return {!proto.nnextractor.NNExtractor}
 */
proto.nnextractor.NNExtractor.prototype.addExtractors = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 10, opt_value, proto.nnextractor.NNExtractor, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.nnextractor.NNExtractor} returns this
 */
proto.nnextractor.NNExtractor.prototype.clearExtractorsList = function() {
  return this.setExtractorsList([]);
};


/**
 * @enum {number}
 */
proto.nnextractor.NNTensorType = {
  NNT_UNSPECIFIED: 0,
  NNT_BOOL: 1,
  NNT_INT8: 2,
  NNT_INT16: 3,
  NNT_INT32: 4,
  NNT_INT64: 5,
  NNT_FLOAT32: 6,
  NNT_FLOAT64: 7,
  NNT_FLOAT16: 8,
  NNT_UINT8: 9,
  NNT_UINT16: 10,
  NNT_UINT32: 11,
  NNT_UINT64: 12,
  NNT_BFLOAT16: 13,
  NNT_COMPLEX32: 14,
  NNT_COMPLEX64: 15,
  NNT_COMPLEX128: 16,
  NNT_UQINT8: 17,
  NNT_QINT8: 18,
  NNT_QINT32: 19,
  NNT_UQINT4: 20,
  NNT_FLOAT8_E4M3FN: 21,
  NNT_FLOAT8_E5M2: 22
};

/**
 * @enum {number}
 */
proto.nnextractor.PrimitiveType = {
  P_UNSPECIFIED: 0,
  P_NULL: 1,
  P_BOOL: 4,
  P_STR: 5,
  P_F64: 6,
  P_F32: 7,
  P_I64: 8,
  P_I32: 9
};

/**
 * @enum {number}
 */
proto.nnextractor.RecursivePrimitiveType = {
  RP_UNSPECIFIED: 0,
  RP_PRIMITIVE: 1,
  RP_PRIMITIVES: 2,
  RP_PRIMITIVE_MAP: 3,
  RP_SLICE: 4
};

/**
 * @enum {number}
 */
proto.nnextractor.OpType = {
  O_UNSPECIFIED: 0,
  O_UNKNOWN: 1,
  O_OTHER: 2,
  O_NONE: 3,
  O_CROP: 4,
  O_PAD: 5,
  O_FLIP: 6,
  O_ORIGIN: 7,
  O_SPACING: 8,
  O_DIRECTION: 9,
  O_AFFINE: 10,
  O_GEO_IDENTITY: 11,
  O_UNFLIP: 12
};

/**
 * @enum {number}
 */
proto.nnextractor.ItemType = {
  I_UNSPECIFIED: 0,
  I_RAW: 1,
  I_OTHER: 2,
  I_NNTENSOR: 3,
  I_NII: 4,
  I_IMAGE: 5,
  I_AUDIO: 6,
  I_SPECTROGRAM: 7,
  I_TEXT: 8,
  I_NUMBER: 9,
  I_TEXT_NUMBER: 10,
  I_NULL: 11,
  I_LIST: 12,
  I_MAP: 13,
  I_OP_ITEM: 14
};

/**
 * @enum {number}
 */
proto.nnextractor.NNRecordType = {
  NNR_UNSPECIFIED: 0,
  NNR_ARRAY: 1,
  NNR_LIST: 3,
  NNR_MAP: 4,
  NNR_META: 5
};

/**
 * @enum {number}
 */
proto.nnextractor.TaskflowType = {
  T_UNSPECIFIED: 0,
  T_INPUT: 1,
  T_PREPROCESS: 2,
  T_FORWARD: 3,
  T_BACKWARD: 4,
  T_POSTPROCESS: 5,
  T_OUTPUT: 6,
  T_EXTRACTOR: 7
};

